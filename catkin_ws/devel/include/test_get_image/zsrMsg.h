// Generated by gencpp from file test_get_image/zsrMsg.msg
// DO NOT EDIT!


#ifndef TEST_GET_IMAGE_MESSAGE_ZSRMSG_H
#define TEST_GET_IMAGE_MESSAGE_ZSRMSG_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/String.h>
#include <std_msgs/String.h>
#include <std_msgs/String.h>
#include <std_msgs/String.h>
#include <std_msgs/String.h>
#include <std_msgs/String.h>
#include <std_msgs/String.h>
#include <std_msgs/String.h>
#include <std_msgs/String.h>
#include <std_msgs/String.h>

namespace test_get_image
{
template <class ContainerAllocator>
struct zsrMsg_
{
  typedef zsrMsg_<ContainerAllocator> Type;

  zsrMsg_()
    : utcTime(0.0)
    , latitude(0.0)
    , longitude(0.0)
    , altitude(0.0)
    , heading(0.0)
    , propertyType()
    , measure(0.0)
    , feature()
    , process()
    , parameter()
    , resultQuality()
    , OrchardID()
    , CameraID()
    , SecondaryCameraID()
    , ImageID()
    , SecondaryImageID()
    , INSlatitude(0.0)
    , INSlongitude(0.0)
    , INSaltitude(0.0)
    , INStime(0.0)  {
    }
  zsrMsg_(const ContainerAllocator& _alloc)
    : utcTime(0.0)
    , latitude(0.0)
    , longitude(0.0)
    , altitude(0.0)
    , heading(0.0)
    , propertyType(_alloc)
    , measure(0.0)
    , feature(_alloc)
    , process(_alloc)
    , parameter(_alloc)
    , resultQuality(_alloc)
    , OrchardID(_alloc)
    , CameraID(_alloc)
    , SecondaryCameraID(_alloc)
    , ImageID(_alloc)
    , SecondaryImageID(_alloc)
    , INSlatitude(0.0)
    , INSlongitude(0.0)
    , INSaltitude(0.0)
    , INStime(0.0)  {
  (void)_alloc;
    }



   typedef double _utcTime_type;
  _utcTime_type utcTime;

   typedef double _latitude_type;
  _latitude_type latitude;

   typedef double _longitude_type;
  _longitude_type longitude;

   typedef double _altitude_type;
  _altitude_type altitude;

   typedef double _heading_type;
  _heading_type heading;

   typedef  ::std_msgs::String_<ContainerAllocator>  _propertyType_type;
  _propertyType_type propertyType;

   typedef double _measure_type;
  _measure_type measure;

   typedef  ::std_msgs::String_<ContainerAllocator>  _feature_type;
  _feature_type feature;

   typedef  ::std_msgs::String_<ContainerAllocator>  _process_type;
  _process_type process;

   typedef  ::std_msgs::String_<ContainerAllocator>  _parameter_type;
  _parameter_type parameter;

   typedef  ::std_msgs::String_<ContainerAllocator>  _resultQuality_type;
  _resultQuality_type resultQuality;

   typedef  ::std_msgs::String_<ContainerAllocator>  _OrchardID_type;
  _OrchardID_type OrchardID;

   typedef  ::std_msgs::String_<ContainerAllocator>  _CameraID_type;
  _CameraID_type CameraID;

   typedef  ::std_msgs::String_<ContainerAllocator>  _SecondaryCameraID_type;
  _SecondaryCameraID_type SecondaryCameraID;

   typedef  ::std_msgs::String_<ContainerAllocator>  _ImageID_type;
  _ImageID_type ImageID;

   typedef  ::std_msgs::String_<ContainerAllocator>  _SecondaryImageID_type;
  _SecondaryImageID_type SecondaryImageID;

   typedef double _INSlatitude_type;
  _INSlatitude_type INSlatitude;

   typedef double _INSlongitude_type;
  _INSlongitude_type INSlongitude;

   typedef double _INSaltitude_type;
  _INSaltitude_type INSaltitude;

   typedef double _INStime_type;
  _INStime_type INStime;





  typedef boost::shared_ptr< ::test_get_image::zsrMsg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::test_get_image::zsrMsg_<ContainerAllocator> const> ConstPtr;

}; // struct zsrMsg_

typedef ::test_get_image::zsrMsg_<std::allocator<void> > zsrMsg;

typedef boost::shared_ptr< ::test_get_image::zsrMsg > zsrMsgPtr;
typedef boost::shared_ptr< ::test_get_image::zsrMsg const> zsrMsgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::test_get_image::zsrMsg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::test_get_image::zsrMsg_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::test_get_image::zsrMsg_<ContainerAllocator1> & lhs, const ::test_get_image::zsrMsg_<ContainerAllocator2> & rhs)
{
  return lhs.utcTime == rhs.utcTime &&
    lhs.latitude == rhs.latitude &&
    lhs.longitude == rhs.longitude &&
    lhs.altitude == rhs.altitude &&
    lhs.heading == rhs.heading &&
    lhs.propertyType == rhs.propertyType &&
    lhs.measure == rhs.measure &&
    lhs.feature == rhs.feature &&
    lhs.process == rhs.process &&
    lhs.parameter == rhs.parameter &&
    lhs.resultQuality == rhs.resultQuality &&
    lhs.OrchardID == rhs.OrchardID &&
    lhs.CameraID == rhs.CameraID &&
    lhs.SecondaryCameraID == rhs.SecondaryCameraID &&
    lhs.ImageID == rhs.ImageID &&
    lhs.SecondaryImageID == rhs.SecondaryImageID &&
    lhs.INSlatitude == rhs.INSlatitude &&
    lhs.INSlongitude == rhs.INSlongitude &&
    lhs.INSaltitude == rhs.INSaltitude &&
    lhs.INStime == rhs.INStime;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::test_get_image::zsrMsg_<ContainerAllocator1> & lhs, const ::test_get_image::zsrMsg_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace test_get_image

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::test_get_image::zsrMsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::test_get_image::zsrMsg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::test_get_image::zsrMsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::test_get_image::zsrMsg_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::test_get_image::zsrMsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::test_get_image::zsrMsg_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::test_get_image::zsrMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "8acb67a9b0a2fd36aee93ed2e2fde2cc";
  }

  static const char* value(const ::test_get_image::zsrMsg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x8acb67a9b0a2fd36ULL;
  static const uint64_t static_value2 = 0xaee93ed2e2fde2ccULL;
};

template<class ContainerAllocator>
struct DataType< ::test_get_image::zsrMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "test_get_image/zsrMsg";
  }

  static const char* value(const ::test_get_image::zsrMsg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::test_get_image::zsrMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64             utcTime\n"
"float64             latitude\n"
"float64             longitude\n"
"float64             altitude\n"
"float64             heading\n"
"\n"
"std_msgs/String     propertyType\n"
"float64             measure\n"
"\n"
"std_msgs/String     feature\n"
"std_msgs/String     process\n"
"std_msgs/String     parameter\n"
"std_msgs/String     resultQuality\n"
"\n"
"std_msgs/String     OrchardID\n"
"std_msgs/String     CameraID\n"
"std_msgs/String     SecondaryCameraID\n"
"std_msgs/String     ImageID\n"
"std_msgs/String     SecondaryImageID\n"
"\n"
"float64             INSlatitude\n"
"float64             INSlongitude\n"
"float64             INSaltitude\n"
"float64             INStime\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/String\n"
"string data\n"
;
  }

  static const char* value(const ::test_get_image::zsrMsg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::test_get_image::zsrMsg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.utcTime);
      stream.next(m.latitude);
      stream.next(m.longitude);
      stream.next(m.altitude);
      stream.next(m.heading);
      stream.next(m.propertyType);
      stream.next(m.measure);
      stream.next(m.feature);
      stream.next(m.process);
      stream.next(m.parameter);
      stream.next(m.resultQuality);
      stream.next(m.OrchardID);
      stream.next(m.CameraID);
      stream.next(m.SecondaryCameraID);
      stream.next(m.ImageID);
      stream.next(m.SecondaryImageID);
      stream.next(m.INSlatitude);
      stream.next(m.INSlongitude);
      stream.next(m.INSaltitude);
      stream.next(m.INStime);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct zsrMsg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::test_get_image::zsrMsg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::test_get_image::zsrMsg_<ContainerAllocator>& v)
  {
    s << indent << "utcTime: ";
    Printer<double>::stream(s, indent + "  ", v.utcTime);
    s << indent << "latitude: ";
    Printer<double>::stream(s, indent + "  ", v.latitude);
    s << indent << "longitude: ";
    Printer<double>::stream(s, indent + "  ", v.longitude);
    s << indent << "altitude: ";
    Printer<double>::stream(s, indent + "  ", v.altitude);
    s << indent << "heading: ";
    Printer<double>::stream(s, indent + "  ", v.heading);
    s << indent << "propertyType: ";
    s << std::endl;
    Printer< ::std_msgs::String_<ContainerAllocator> >::stream(s, indent + "  ", v.propertyType);
    s << indent << "measure: ";
    Printer<double>::stream(s, indent + "  ", v.measure);
    s << indent << "feature: ";
    s << std::endl;
    Printer< ::std_msgs::String_<ContainerAllocator> >::stream(s, indent + "  ", v.feature);
    s << indent << "process: ";
    s << std::endl;
    Printer< ::std_msgs::String_<ContainerAllocator> >::stream(s, indent + "  ", v.process);
    s << indent << "parameter: ";
    s << std::endl;
    Printer< ::std_msgs::String_<ContainerAllocator> >::stream(s, indent + "  ", v.parameter);
    s << indent << "resultQuality: ";
    s << std::endl;
    Printer< ::std_msgs::String_<ContainerAllocator> >::stream(s, indent + "  ", v.resultQuality);
    s << indent << "OrchardID: ";
    s << std::endl;
    Printer< ::std_msgs::String_<ContainerAllocator> >::stream(s, indent + "  ", v.OrchardID);
    s << indent << "CameraID: ";
    s << std::endl;
    Printer< ::std_msgs::String_<ContainerAllocator> >::stream(s, indent + "  ", v.CameraID);
    s << indent << "SecondaryCameraID: ";
    s << std::endl;
    Printer< ::std_msgs::String_<ContainerAllocator> >::stream(s, indent + "  ", v.SecondaryCameraID);
    s << indent << "ImageID: ";
    s << std::endl;
    Printer< ::std_msgs::String_<ContainerAllocator> >::stream(s, indent + "  ", v.ImageID);
    s << indent << "SecondaryImageID: ";
    s << std::endl;
    Printer< ::std_msgs::String_<ContainerAllocator> >::stream(s, indent + "  ", v.SecondaryImageID);
    s << indent << "INSlatitude: ";
    Printer<double>::stream(s, indent + "  ", v.INSlatitude);
    s << indent << "INSlongitude: ";
    Printer<double>::stream(s, indent + "  ", v.INSlongitude);
    s << indent << "INSaltitude: ";
    Printer<double>::stream(s, indent + "  ", v.INSaltitude);
    s << indent << "INStime: ";
    Printer<double>::stream(s, indent + "  ", v.INStime);
  }
};

} // namespace message_operations
} // namespace ros

#endif // TEST_GET_IMAGE_MESSAGE_ZSRMSG_H
